Datei: src/controllers/adminController.js
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const AdminUser = require('../models/adminUser');

// Admin Login
const loginAdmin = async (req, res) => {
  const { email, password } = req.body;

  try {
    const adminUser = await AdminUser.findOne({ email });

    if (!adminUser) {
      return res.status(400).send('Admin Benutzer nicht gefunden');
    }

    const isMatch = await bcrypt.compare(password, adminUser.password);

    if (!isMatch) {
      return res.status(400).send('Ungültige Anmeldedaten');
    }

    const token = jwt.sign({ id: adminUser._id, email: adminUser.email }, process.env.JWT_SECRET, { expiresIn: '1h' });
    res.status(200).json({ token });
  } catch (error) {
    res.status(500).send('Serverfehler');
  }
};

// Admin Registrierung
const registerAdmin = async (req, res) => {
  const { email, password, name, privacy } = req.body;

  try {
    const hashedPassword = await bcrypt.hash(password, 10);
    const newAdminUser = new AdminUser({ email, password: hashedPassword, name, privacy });
    await newAdminUser.save();
    res.status(201).send('Admin Benutzer erfolgreich erstellt');
  } catch (error) {
    res.status(500).send('Serverfehler');
  }
};

// Alle Benutzer abrufen
const getUsers = async (req, res) => {
  try {
    const users = await AdminUser.find();
    res.status(200).json(users);
  } catch (error) {
    res.status(500).send('Fehler beim Abrufen der Benutzer.');
  }
};

// Benutzer nach ID abrufen
const getUser = async (req, res) => {
  const userId = req.params.id;

  try {
    const user = await AdminUser.findById(userId);
    if (user) {
      res.status(200).json(user);
    } else {
      res.status(404).send('Benutzer nicht gefunden');
    }
  } catch (error) {
    res.status(500).send('Fehler beim Abrufen des Benutzers.');
  }
};

module.exports = {
  loginAdmin,
  registerAdmin,
  getUsers,
  getUser
};

Datei: src/controllers/contactController.js
const { validationResult } = require('express-validator');
const nodemailer = require('nodemailer');
const moment = require('moment');
const Contact = require('../models/contact');
const { encrypt } = require('../utils/encryption');

const sendEmail = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { salutation, name, email, company, message, privacy } = req.body;

  if (privacy !== 'on') {
    return res.status(400).json({ message: 'Datenschutzerklärung muss akzeptiert werden.' });
  }

  const encryptedMessage = encrypt(message);
  const timestamp = new Date();

  const contact = new Contact({
    salutation,
    name,
    email,
    company,
    message: encryptedMessage,
    privacy: true,
    timestamp,
  });

  try {
    await contact.save();
  } catch (error) {
    return res.status(500).json({ message: 'Fehler beim Speichern des Kontakts.' });
  }

  const transporter = nodemailer.createTransport({
    host: 'smtp.gmail.com',
    port: 587,
    secure: false,
    auth: {
      user: process.env.EMAIL,
      pass: process.env.EMAIL_PASSWORD
    }
  });

  const mailOptionsToYou = {
    from: email,
    to: process.env.EMAIL,
    subject: `Neue Nachricht von ${salutation} ${name} (${company})`,
    html: `<p>${salutation} ${name} <br>(Unternehmen: ${company})<br> schrieb am ${moment(timestamp).format('DD.MM.YYYY HH:mm:ss')} folgende Nachricht:</p>
           <p>${message}</p>
           <p>Email: ${email}</p>
           <p style="font-size: 10px;">Dies ist eine automatisch erstellte Mail. Ihre Erstellung und ihre Zusendung wurde durch die Nutzung unseres auf unserer unternehmenseigenen Website befindlichen Kontaktformulars initiiert.</p>`
  };

  const salutationFormatted = salutation === "Herr" ? "Sehr geehrter Herr" : "Sehr geehrte Frau";
  const mailOptionsToSender = {
    from: process.env.EMAIL,
    to: email,
    subject: 'Ihre Nachricht an Omega Security GmbH',
    html: `<p>${salutationFormatted} ${name},</p>
           <p>wir haben Ihre Nachricht erhalten und werden uns in Kürze bei Ihnen melden.</p>
           <p>Mit freundlichen Grüßen,<br>Omega Security GmbH</p>`
  };

  try {
    await transporter.sendMail(mailOptionsToYou);
    await transporter.sendMail(mailOptionsToSender);
    res.status(200).json({ message: 'E-Mail erfolgreich gesendet!' });
  } catch (error) {
    res.status(500).json({ message: 'Fehler beim Senden der E-Mail.' });
  }
};

module.exports = {
  sendEmail
};

Datei: src/index.js
require('dotenv').config();
const express = require('express');
const https = require('https');
const fs = require('fs');
const path = require('path');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cors = require('cors');
const morgan = require('morgan');
const mongoose = require('mongoose');
const multer = require('multer');
const upload = multer();

const app = express();

// Sicherheitsheader hinzufügen
app.use(helmet());

// Angepasste Content Security Policy (CSP)
app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'", 'cdn.jsdelivr.net', 'cdnjs.cloudflare.com', 'ajax.googleapis.com', 'maxcdn.bootstrapcdn.com', 'unpkg.com', 'stackpath.bootstrapcdn.com', 'code.jquery.com'],
    styleSrc: ["'self'", "'unsafe-inline'", 'fonts.googleapis.com', 'cdnjs.cloudflare.com', 'maxcdn.bootstrapcdn.com', 'stackpath.bootstrapcdn.com'],
    imgSrc: ["'self'", 'data:', 'cdn.jsdelivr.net', 'cdnjs.cloudflare.com'],
    connectSrc: ["'self'", 'api.example.com'],
    fontSrc: ["'self'", 'fonts.gstatic.com', 'cdnjs.cloudflare.com', 'maxcdn.bootstrapcdn.com'],
    objectSrc: ["'none'"],
    mediaSrc: ["'self'"],
    frameSrc: ["'none'"]
  }
}));

// CORS-Konfiguration
app.use(cors());

// Rate Limiting für Anmelde- und Registrierungsrouten
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 Minuten
  max: 100, // Beschränkung auf 100 Anfragen pro IP und Fenster
  message: 'Zu viele Anfragen von dieser IP, bitte versuchen Sie es später erneut.',
});
app.use('/admin/login', limiter);
app.use('/admin/register', limiter);

// Middleware für JSON-Parsing
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Logging hinzufügen
app.use(morgan('combined'));

// Statische Dateien bereitstellen
app.use(express.static(path.join(__dirname, '..', 'public')));

const options = {
  key: fs.readFileSync(path.join(__dirname, '../server.key')),
  cert: fs.readFileSync(path.join(__dirname, '../server.cert')),
};

// Beispielrouten
const adminRoutes = require('./routes/admin');
const contactRoutes = require('./routes/contact');

app.use('/admin', adminRoutes);
app.use('/contact', contactRoutes);

// Verbindung zur MongoDB
mongoose.connect(process.env.MONGO_URI, {
  serverSelectionTimeoutMS: 30000, // Timeout auf 30 Sekunden setzen
})
  .then(() => console.log('Mit MongoDB verbunden'))
  .catch(err => console.error('Fehler bei der Verbindung zur MongoDB:', err));

// HTTPS-Server starten
https.createServer(options, app).listen(process.env.PORT, () => {
  console.log(`Server läuft auf https://localhost:${process.env.PORT}`);
});

Datei: src/middleware/auth.js
const jwt = require('jsonwebtoken');

const authMiddleware = (req, res, next) => {
    const token = req.header('Authorization')?.replace('Bearer ', '');

    if (!token) {
        return res.status(401).send('Access denied. No token provided.');
    }

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = decoded;
        next();
    } catch (ex) {
        res.status(400).send('Invalid token.');
    }
};

module.exports = authMiddleware;

Datei: src/models/adminUser.js
const mongoose = require('mongoose');

const adminUserSchema = new mongoose.Schema({
    email: { 
        type: String, 
        required: true, 
        unique: true,
        match: [/^\S+@\S+\.\S+$/, 'is invalid'],
        index: true
    },
    password: { 
        type: String, 
        required: true,
        minlength: [6, 'Password must be at least 6 characters long']
    },
    name: { 
        type: String, 
        required: true 
    },
    privacy: { 
        type: Boolean, 
        required: true 
    }
}, { timestamps: true });

const AdminUser = mongoose.model('AdminUser', adminUserSchema);

module.exports = AdminUser;

Datei: src/models/contact.js
const mongoose = require("mongoose");

const contactSchema = new mongoose.Schema({
  salutation: {
    type: String,
    required: true,
    enum: ["Herr", "Frau"],
  },
  name: {
    type: String,
    required: true,
    minlength: 2,
    maxlength: 50,
  },
  email: {
    type: String,
    required: true,
    match: [/^\S+@\S+\.\S+$/, "is invalid"],
  },
  company: {
    type: String,
    maxlength: 100,
  },
  message: {
    type: String,
    required: true,
    minlength: 10,
    maxlength: 500,
  },
  privacy: {
    type: Boolean,
    required: true,
  },
  timestamp: {
    type: Date,
    default: Date.now,
    required: true,
  },
});

const Contact = mongoose.model("Contact", contactSchema);

module.exports = Contact;

Datei: src/routes/admin.js
const express = require('express');
const { check, validationResult } = require('express-validator');
const router = express.Router();
const {
    loginAdmin,
    registerAdmin,
    getUsers,
    getUser
} = require('../controllers/adminController');
const authMiddleware = require('../middleware/auth');

// Route für Admin-Registrierung mit Authentifizierung und Validierung
router.post('/register', authMiddleware, [
    check('email').isEmail().withMessage('Muss eine gültige E-Mail sein'),
    check('password').isLength({ min: 6 }).withMessage('Das Passwort muss mindestens 6 Zeichen lang sein'),
    check('name').notEmpty().withMessage('Name ist erforderlich'),
    check('privacy').isBoolean().withMessage('Datenschutzbestimmung muss akzeptiert werden')
], (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    next();
}, registerAdmin);

// Route für Admin-Login mit Validierung
router.post('/login', [
    check('email').isEmail().withMessage('Muss eine gültige E-Mail sein'),
    check('password').notEmpty().withMessage('Passwort ist erforderlich')
], (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    next();
}, loginAdmin);

// Route zum Abrufen aller Benutzer mit Authentifizierung
router.get('/users', authMiddleware, getUsers);

// Route zum Abrufen eines Benutzers anhand der ID mit Authentifizierung
router.get('/users/:id', authMiddleware, getUser);

module.exports = router;

Datei: src/routes/contact.js
const express = require("express");
const router = express.Router();
const nodemailer = require("nodemailer");
const moment = require("moment");
const Contact = require("../models/contact");
const { encrypt, decrypt } = require("../utils/encryption");
const authMiddleware = require("../middleware/auth");
const multer = require("multer");
const upload = multer();

const sendEmail = async (req, res) => {
  const { salutation, name, email, company, message, privacy } = req.body;

  if (privacy !== "on") {
    return res.status(400).send("Datenschutzerklärung muss akzeptiert werden.");
  }

  const encryptedMessage = encrypt(message);
  const timestamp = moment().toDate();

  const contact = new Contact({
    salutation,
    name,
    email,
    company,
    message: encryptedMessage,
    privacy: true,
    timestamp,
  });

  try {
    await contact.save();
    console.log("Kontakt erfolgreich gespeichert");
  } catch (error) {
    console.error("Fehler beim Speichern des Kontakts:", error);
    return res.status(500).send("Fehler beim Speichern des Kontakts.");
  }

  const transporter = nodemailer.createTransport({
    host: "smtp.gmail.com",
    port: 587,
    secure: false,
    auth: {
      user: process.env.EMAIL,
      pass: process.env.EMAIL_PASSWORD,
    },
  });

  const mailOptionsToYou = {
    from: email,
    to: process.env.EMAIL,
    subject: `Nachricht von ${salutation} ${name} (${company})`,
    html: `<p>${salutation} ${name} <br>(Unternehmen: ${company})<br> schrieb am ${moment(timestamp).format(
      "DD.MM.YYYY HH:mm:ss"
    )} folgende Nachricht:</p>
           <p>${message}</p>
           <p>Email: ${email}</p>
           <p style="font-size: 10px;">Dies ist eine automatisch erstellte Mail. Ihre Erstellung und ihre Zusendung wurde durch die Nutzung unseres auf unserer unternehmenseigenen Website befindlichen Kontaktformulars initiiert.</p>`,
  };

  const salutationFormatted = salutation === "Herr" ? "Sehr geehrter Herr" : "Sehr geehrte Frau";
  const mailOptionsToSender = {
    from: process.env.EMAIL,
    to: email,
    subject: "Ihre Nachricht an Omega Security GmbH",
    html: `<p>${salutationFormatted} ${name},</p>
           <p>wir haben Ihre Nachricht erhalten und werden uns in Kürze bei Ihnen melden.</p>
           <p>Mit freundlichen Grüßen,<br>Omega Security GmbH</p>`,
  };

  try {
    await transporter.sendMail(mailOptionsToYou);
    console.log("E-Mail an Sie erfolgreich gesendet");

    await transporter.sendMail(mailOptionsToSender);
    console.log("Bestätigungs-E-Mail erfolgreich gesendet");

    res.status(200).send("E-Mail erfolgreich gesendet!");
  } catch (error) {
    console.error("Fehler beim Senden der E-Mail:", error);
    res.status(500).send("Fehler beim Senden der E-Mail.");
  }
};

const getDecryptedContacts = async (req, res) => {
  try {
    const contacts = await Contact.find();
    const decryptedContacts = contacts.map((contact) => ({
      ...contact._doc,
      message: decrypt(contact.message),
    }));
    res.status(200).json(decryptedContacts);
  } catch (error) {
    console.error("Fehler beim Abrufen der Kontakte:", error);
    res.status(500).send("Fehler beim Abrufen der Kontakte.");
  }
};

// Öffentliche Route für das Kontaktformular
router.post("/send-email", upload.none(), sendEmail);

// Private Route zum Abrufen der Kontakte
router.get("/get-decrypted-contacts", authMiddleware, getDecryptedContacts);

module.exports = router;

Datei: src/utils/encryption.js
const crypto = require('crypto');
const dotenv = require('dotenv');
const path = require('path');

dotenv.config({ path: path.resolve(__dirname, '../../.env') });

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY;
const IV_LENGTH = 16;

function encrypt(text) {
    let iv = crypto.randomBytes(IV_LENGTH);
    let cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(ENCRYPTION_KEY, 'hex'), iv);
    let encrypted = cipher.update(text);

    encrypted = Buffer.concat([encrypted, cipher.final()]);

    return iv.toString('hex') + ':' + encrypted.toString('hex');
}

function decrypt(text) {
    let textParts = text.split(':');
    let iv = Buffer.from(textParts.shift(), 'hex');
    let encryptedText = Buffer.from(textParts.join(':'), 'hex');
    let decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(ENCRYPTION_KEY, 'hex'), iv);
    let decrypted = decipher.update(encryptedText);

    decrypted = Buffer.concat([decrypted, decipher.final()]);

    return decrypted.toString();
}

module.exports = { encrypt, decrypt };

